## Module requirements

  dns      = require 'dns'
  fs       = require 'fs'
  mailer   = require 'nodemailer'
  libxml   = require 'libxmljs'
  libxslt  = require 'node_xslt'
  punycode = require 'punycode'

## Module exports

  exports.sendEmail = ( data, cb ) ->

    data.from = "#{data.callback_code}.cb@#{data.base_domain}"

    getParts data, ( err, html, css, svg ) =>
      if err then return cb err

      jsm = 'XSS(1) security vulnerability found! Please report this to xss@emailprivacytester.com'
      js1 = 'alert(unescape(/' + hexEncode(jsm) + '/.source))'
      js2 = '<script>alert(unescape(/' + hexEncode(jsm.replace '(1)', '(2)') + '/.source))</script>'

      mailerOpt =
        envelope:
          from:  "env.#{@emailToASCII data.from}"
          to:  @emailToASCII data.to
        from:    "\"Email Privacy Tester\" <from.#{@emailToUnicode data.from}>"
        replyTo:  "\"Email Privacy Tester\" <rt.#{@emailToUnicode data.from}>"
        to:    @emailToUnicode data.to
        subject:  "Email Privacy Tester - Test Email (#{data.lookup_code})"
        html:    html
        headers:
          'Return-Receipt-To':           "<rr.#{@emailToUnicode data.from}>"
          'Disposition-Notification-To': "\"Email Privacy Tester\" <dn.#{@emailToUnicode data.from}>"
        attachments:  [
          { filename: "#{data.callback_code}.css", contents: css, cid: "#{data.callback_code}.css@#{data.base_domain}", contentDisposition: 'inline', contentType: 'text/css' }
          { filename: "#{data.callback_code}.svg", contents: svg, cid: "#{data.callback_code}.svg@#{data.base_domain}", contentDisposition: 'inline', contentType: 'image/svg+xml' }
          { filename: "#{js2}.#{data.callback_code}.png", contents: js1, cid: "#{data.callback_code}.js@#{data.base_domain}", contentDisposition: 'inline', contentType: 'image/png' }
        ]
    
      transport = mailer.createTransport 'SMTP', ignoreTLS: true
      transport.sendMail mailerOpt, ( err, res ) ->
        transport.close()
        unless err? then return cb null, res.message

        switch err.name
          when 'RecipientError' then cb 'Invalid email address'
          else cb err.message

  exports.validateFormat = ( email ) ->
    email  = @emailToASCII email
    return email.match ".+@([a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?\\.)*[a-zA-Z]{2,}$"

  exports.validate = ( email, cb ) ->
    email  = @emailToASCII email
    domain = email.replace /.+@/, ''

    if @validateFormat email
      dns.resolve domain, 'MX', ( err, addresses ) ->
        if err? and err.code in [ dns.NODATA, dns.NOTFOUND ]
          [ successes, errors ] = [ 0, 0 ]
          for type in [ 'AAAA', 'A' ]
            dns.resolve domain, type, ( err, addresses ) ->
              if addresses? and addresses.length then ++successes else ++errors
              if successes+errors == 2
                if successes then cb null else cb 'Failed looking up DNS records'
        else if err?
          cb "Error looking up MX records: #{err.code}"
        else
          cb null

      local_part = email.replace /(.+)@.+/, '$1'
    else
      cb 'Invalidly formatted domain name'

  exports.emailToUnicode = ( email ) ->
    return email unless email.match /.@./
    local_part = email.replace /(.+)@.+/, '$1'
    domain     = punycode.toUnicode email.replace /.+@/, ''
    return "#{local_part}@#{domain}"

  exports.emailToASCII = ( email ) ->
    return email unless email.match /.@./
    local_part = email.replace /(.+)@.+/, '$1'
    domain     = punycode.toASCII email.replace /.+@/, ''
    return "#{local_part}@#{domain}"

## Get all parts

  getParts = ( data, cb ) ->
    [ failed, html, css, svg ] = [ false, null, null, null ]
    getMimePart 'html.xsl', data, ( err, plain ) ->
      return if failed
      if err
        failed = true
        return cb err
      html = plain
      cb null, html, css, svg if html? && css? && svg?
    getMimePart 'css.xsl',  data, ( err, plain ) ->
      return if failed
      if err
        failed = true
        return cb err
      css = plain
      cb null, html, css, svg if html? && css? && svg?
    getMimePart 'svg.xsl',  data, ( err, plain ) ->
      return if failed
      if err
        failed = true
        return cb err
      svg = plain
      cb null, html, css, svg if html? && css? && svg?

## Get a MIME part

  getMimePart = ( path, data, cb ) ->
    path = "#{__dirname}/#{path}"
    xml = buildXML data
    readXSL path, ( err, stylesheet ) ->
      if err then return cb err, null
      html = libxslt.transform stylesheet, xml, []
      cb null, html

## Build a simple XML object from the supplied data

  buildXML = ( data ) ->
    doc = new libxml.Document '1.0'
    content = doc.node 'content'
    content.node key, val for key, val of data
    return libxslt.readXmlString doc.toString()

## Read and parse an XSL stylesheet

  readXSL = ( path, cb ) ->
    fs.readFile path, ( err, xsltString ) ->
      if err
        cb err, null
      else
        try
          cb null, libxslt.readXsltString xsltString
        catch e
          cb e, null

## Hex encode a string. Like the standard escape function but does it to *every* character

  hexEncode = ( str ) ->
    ret = ''
    c = str.length
    while c 
      hexChar = str.charCodeAt(--c).toString(16)
      if hexChar.length < 2 then hexChar = '0' + hexChar
      ret = '%' + hexChar + ret
    return ret
