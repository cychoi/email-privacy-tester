## Module requirements

  fs       = require 'fs'
  libxml   = require 'libxmljs'
  util     = require 'util'

## Store the mtime of the tests file when it was last read

  lastMtime   = 0
  lastChecked = 0
  tests       = [] 
  readQueue   = null 

## Module exports

  exports.get = ( name, cb ) ->
    if arguments.length == 1 then return @readTests arguments[0]

    @readTests (tests) ->
      return cb tests[name] if tests[name]?
      cb null

## Read tests. Only actually re-reads the file if it needs to

  exports.readTests = ( cb ) ->
    path = "#{__dirname}/tests.xml"

    return readQueue.push(cb) if readQueue?
    readQueue = [cb]

    ## Don't even bother stating the tests file if it has been done within the last 3 seconds
    if lastChecked > Date.now()-3000
      queued?(tests) for queued in readQueue
      return readQueue = null
    lastChecked = Date.now()

    fs.stat path, ( err, stats ) ->
      if err?
        queued?(tests) for queued in readQueue
        return readQueue = null
      else
        if Date.parse(stats.mtime) > lastMtime
          lastMtime = Date.parse(stats.mtime)
          readXML path, ( err, doc ) ->
            unless err?
              tests = {} 
              rx = new RegExp "^[\\r\\n\\t]*(.*?)$", "gm"
              for test in doc.root().find '*'
                tests[test.name()] =
                  type: test.get('type').text()
                  shortDesc: test.get('name').text()
                  longDesc: test.get('desc').text()
            queued?(tests) for queued in readQueue
            return readQueue = null
        else
          queued?(tests) for queued in readQueue
          return readQueue = null

## Read and parse an XSL stylesheet

  readXML = ( path, cb ) ->
    fs.readFile path, ( err, buffer ) ->
      if err
        cb err, null
      else
        try
          xml = libxml.parseXmlString buffer.toString()
          cb null, xml
        catch e
          cb e, null
